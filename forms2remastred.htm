<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<script type='text/javascript' src='knockout/knockout-2.2.1.debug.js'></script>
<script type='text/javascript' src='knockout/knockout.validation.js'></script>
<script type='text/javascript' src='knockout/sko.js'></script>
<link rel=stylesheet type="text/css" href="knockout/sko.css">
<style>
</style>
</head>
<body onload="Init();">
<div data-bind="foreach:T1">
	<p>
	<span data-bind="text:f1"></span>
	<span data-bind="text:f2"></span>
	<span data-bind="text:rel1().year"></span>
	<input data-bind="value:rel1().rel2().rel3().f1">
	<div data-bind="foreach:brel0">
		<span data-bind="text:f0" style="color:red;"></span>
	</div>
	<span data-bind="text:rel1().rel2().f3"></span>
	<span data-bind="text:rel1().rel2().rel3().f1"></span>
	<div data-bind="foreach:rel1().brel1">
		<span data-bind="text:f1" style="color:green;"></span>
	</div>
	<a data-bind="visible:rel1().brel1.ready()">готово</a>
	<a data-bind="click:rel1().brel1.sendQuery">раскрыть</a>
	<hr>
	</p>
	<!--p data-bind="text:rel1.value"></p>
	<p data-bind="text:rel1('Россия:2012').f2"></p>
	<p data-bind="text:rel1('Россия:2013').f2"></p>
		<div data-bind="foreach:rel12()">
			<p data-bind="text:f2"></p>
		</div>
	<p data-bind="text:rel1().rel2.value"></p>
	<p data-bind="text:rel1().rel2().f3"></p-->
</div>
<pre id="json" style="background-color:lightgreen"></pre>
<pre id="jsonpaste"></pre>
<script>
	function patchModel(model) {
		for(var i in model) {
			var table = model[i];
			table.name = i;
			for(var j in table) {
				var field = table[j];
				field.name = j;
				if(field.target) {
					field.target = model[field.target];
				}
			}
		}
		return model;
	}
	var metaModel = patchModel({
		T0:{
			id:{caption:'id'},
			f0:{caption:'Ф 0'},
			rel0:{caption:'',target:'T1',condition:[{there:'id',here:'rel0'}]}
		},
		T1:{
			id:{caption:'id'},
			f1:{caption:'Ф 1'},
			f2:{caption:'Фамилия'},
			brel0:{caption:'Бэкрел 0',target:'T0',condition:[{there:'rel0',here:'id'}], array:'auto'},
			rel1:{caption:'Рел 1',target:'T2',condition:[{there:'f2',value:'?'},{there:'year',value:'?'},{there:'id',here:'rel1'}]},
		},
		T2:{
			year:{ caption: 'Год'},
			id:{caption:'id'},
			f2:{caption:'Ф 2'},
			rel2:{caption:'Рел 2',target:'T3',condition:[{there:'id',here:'rel2'}]},
			brel1:{caption:'Бэкрел 1',target:'T1',condition:[{there:'rel1',here:'id'}], array:'defer'}
		},
		T3:{
			id:{caption:'id'},
			f3:{caption:'Ф 3'},
			rel3:{caption:'Рел циклический',target:'T1',condition:[{there:'id',here:'rel3'}]},
			brel2:{caption:'Бэкрел 2',target:'T2',condition:[{there:'rel2',here:'id'}], array:'defer'}
		}
	});
X.DBdefaultEnv = {
		//elm - observable
		//read from observable
		read: function(elm) { return elm.value; },
		//write to observable or observableArray
		write: function(elm, value) {
			if(this.isMulti(elm) && X.isArray(value)) {
				for(var i = 0;i < value.length;++i) {
					var k = 0, usage = [];
					var node = elm.appendElement();
					X.modelBuilder.setupLinkedUsage(node);
					X.modelBuilder.collectUsage(node, usage);
					for(var j in value[i]) {
						//TODO: server answer value length may be greater than usage. should check it and alert
						var cell = value[i][j];
						if(X.isArray(cell)) 
							X.DBdefaultEnv.write(usage[k].elem, cell)
						else 
							(usage[k].elem.joins ? usage[k].elem.value : usage[k].elem)(value[i][j]);
						k++;
					}
				}
				elm.ready(true);
			} else if(!this.isMulti(elm) && !X.isArray(value)) {
				(elm.joins ? elm.value : elm)(value); 
			}
			
		},
		//mark observable as it has error when data came from server
		//(usuccessfull try to write data)
		writeSaveError: function(elm, err) { alert(err); /*or set attribute!*/ },
		//check if this observable bound to something (need to be read)
		used: function(elm) {
			return elm.getSubscriptionsCount && elm.getSubscriptionsCount(); 
		},
		//check if this observable bound to input or can be changed somehow else
		boundAsUpdatable: function(elm) { return elm.boundAsUpdatable; },
		//make observable with name in container using fielddef as description
		makeElement: function(container, name, fielddef) {
			var c = container[name] = ko.observable();
			c.$ = fielddef;
			c.parent = container;
		},
		isMulti:function(elm) {return elm.appendElement },
		//convert element (made with makeElement) to writable one (which is able to send itself to server)
		convertToUpdatable: function(elm) {},
		//make relation, eq rel() = X.modelBuilder.traverseRel
		// but with additionals members
		// like joins{}, val, and so on
		makeRelation: function(container, name, fielddef) {
				var c = container[name] = function() { return X.modelBuilder.traverseRel.apply(this[name], arguments); }
				c.joins = {}
				c.$ = fielddef;
				c.parent = container;
				X.DBdefaultEnv.makeElement(c, 'value', fielddef); //observable = rel value (as field value)
				//TODO:
				//1) array to choose rel (if editable!) (it's like subitems = our array, but without where)
				//2) text - observable to show rel in UI (may be same as val)
				//3) tip - observable to show rel's light details
				// and maybe something to our relation bind
		},
		makeArray: function(container, name, def) {
			var env = this;
			var c = container[name] = ko.observableArray();
			console.log(def.name+' is used:'+env.used(c));
			c.$ = def;
			c.parent = container;
			c.auto = def.array && def.array.indexOf('auto')==0;
			c.defer = def.array && def.array.indexOf('defer')==0;
			c.ready = ko.observable();
			c.appendElement = function(obj) {
				var table_node = (obj || new X.modelBuilder.tableNode(def.target || def));
				if(c.external) table_node.external = c.external();//условия для backrel
				c.push(table_node);
				return table_node;
			}
			c.destroyElement = function(obj) {
				c.remove(obj);
			}
			c.makeQuery = function(context) {
				var init_node = c.appendElement();
				var sql = X.modelBuilder.makeSQL(init_node, context);
				c.destroyElement(init_node);
				return sql;
			}
			c.sendQuery = function(context) {
				c.ready(false);
				var json = X.modelBuilder.sqlToJSON(c.makeQuery(context));
				env.send(json, function(data) { env.write(c, data) });
			}
		},
		onSendError: X.log,
		url: "/save",
		send: function(data, onresponce, onerror) {
			/*
			var p = X.XHR("POST", this.url, data)
					.then(onresponce, onerror)
					.done();
			*/
			var seen = [];
			document.getElementById('json').innerHTML = JSON.stringify(data,
				function(key, val) {return val});
			document.getElementById('jsonpaste').innerHTML = JSON.stringify(data,
				function(key, val) {return val}, 2);
			onresponce(SQLTODATA(data));
		},
		interval: 300,
		timeout: 10*1000
}
X.throttle = function(func, wait) {
	var context, args, timeout, result;
	var previous = 0;
	var later = function() {
		previous = new Date;
		timeout = null;
		result = func.apply(context, args);
	};
	return function() {
		var now = new Date;
		var remaining = wait - (now - previous);
		context = this;
		args = arguments;
		if (remaining <= 0) {
			clearTimeout(timeout);
			timeout = null;
			previous = now;
			result = func.apply(context, args);
		} else if (!timeout) {
			timeout = setTimeout(later, remaining);
		}
		return result;
	};
};
X.DB = (function(env) {
	function newQueue() { return { cmds: [] } }
	var DBQueue = newQueue();
	var sentDBQueue = null;
	var lockSending = 0;
	var cmdsWhenLocked = 0;

	function _processQueue() {
		if(lockSending) { ++cmdsWhenLocked; return; }

		if(DBQueue.cmds.length === 0) return;
		
		var to_send_queue = { seed: X.cid.seed(), cmds: [] }
		
		for(i = 0; i < DBQueue.cmds.length; ++i) {
			var qe = DBQueue.cmds[i];
			var to_send = { table: qe.keyObject.DBTableDescr.DBName, 
					key: qe.keyObject.DBKeyValue,
					oid: X.OID(qe.keyObject) 
					}
			if(qe.objects) { //update/insert
				to_send.values = {}
				var hasChanges = false;
				for(var j in qe.objects) {
					var v = env.read(qe.objects[j]);
					// due to toJSON isCid translated to {cid:val} which is enough
					if(v !== objs.DBValue) //changed
						to_send.values[hasChanges = j] = v;
				}
				if(hasChanges)
					to_send_queue.push(to_send);
			} else { //delete
				if(qe.keyObject.DBKeyValue) //!DBKeyValue - new
					to_send_queue.push(to_send);
			}
		}

		var j = JSON.stringify(to_send_queue);
		sentDBQueue = DBQueue;
		DBQueue = newQueue();
		env.send(j, onresponce, onerror)
	}
	var processQueue = X.throttle(_processQueue, env.interval);
	function sendToServer(elm) {
		var n = { keyObject: elm.keyObject, objects: {} }
		{
			var last = DBQueue.cmds.slice(-1)[0];
			var qe = 
				last && n.keyObject === last.keyObject ? last
				: (DBQueue.cmds.push(n), n);
			if(qe.objects) //if not destroyed!
				qe.objects[elm.DBFieldDescr.DBName] = elm;
			if(elm.keyObject._destroy)
				qe.objects = null;
		}
		processQueue();
	}
	var errorCount = 0;
	function onerror(err) {
		//log...
		env.onSendError("server responce:", err);
		++errorCount;
		//resend... 
		DBQueue.cmds = sentDBQueue.cmds.concat(DBQueue.cmds);
		sentDBQueue = null;
		processQueue();
	}
	function onresponce(txt) {
		errorCount = 0;
		var js = JSON.parse(txt); //isCid NOT used
		//must match!
		var a = js.cmds;
		var objs = sentDBQueue.cmds;
		for(var t = 0; t < a.length; ++t)
		{
			var s = a[t]; //
			var c = objs[t].keyObject; //must match previous!
			if(s.oid !== X.OID(c)) {
				//TODO: check match!
			}
			if(s.error)
				env.writeSaveError(c, s.error);
			else
				if(s.values) {
					//insert/update
					for(var i in s.values) {
						var obj = c.objects[i];
						if(obj) {
							obj.DBValue = s.values[i]; //from server!!!! cids translated there!!!
							if(env.read(obj) !== obj.DBValue)
								env.write(obj, obj.DBValue); //if server change value
						} else {
							//server send new value, but does't ask it to change
						}
					}
					//recalculate key for whole row
					//DBKeyValue has db values
					var k = {};
					for(var i in c.values) //loop in keyObject
						k[c[i].DBFieldDescr.DBName] = c[i].DBValue; //new DBValue here!
					c.DBKeyValue = k;
				} else {
					//delete
					c.DBKeyValue = null; //clear key value from deleted records
				}
		}
		sentDBQueue = null;
	}
	return {
		toServer: sendToServer,

		lockSending: function() { ++lockSending; },
		unlockSending: function() { 
					if(--lockSending == 0 && cmdsWhenLocked) {
						processQueue(); cmdsWhenLocked = 0;
					} 
				},
		withLockedSending: function(f) { 
			try { this.lockSending(); return f(); } 
			finally { this.unlockSending(); } 
		},
		
		key: function(DBTableDescr, vals) { // получает { value: KO }
			this.DBTableDescr = DBTableDescr;
			//this.DBValue = undefined; //TODO: calc it when we read object from server, and set ready = true
			this.values = vals; //to make DBKeyValue and to trace changes in key 
			this.pended_changes = {}; // objects; pended_changes === null when ready
			this.ready = function() {
				for(var i in this.values) {
					var v = env.read(this.values[i]);
					if(X.isEmpty(v))
						return false; // has empty val -> not a pk! so, not ready
				}
				if(this.pended_changes)
					for(var i in this.pended_changes)
						X.DB.sendToServer(this.pended_changes[i]);
				this.pended_changes = null;
				return true;
			}
			this.sendToServer = function(elm) {
				if(this.pended_changes) { // save in pended changes, is key is not ready
					this.pended_changes[elm.DBFieldDescr.DBName] = elm; //unique!
				} else {
					X.DB.sendToServer(elm);
				}
			}
			//TODO: subscibe to change key
			// i.e. set ready as this.ready = KO.computed(this.ready, this)
			return this;
		},
		new_key: function(DBTableDescr, vals) { return new key(DBTableDescr, vals); }
		
		//TODO: move to prototype
		//array: 1) combo items -> filled in filter -> so in select when data come 
		// 2) subitems -> filled in select  when data come
		// one object filled in select when data come
	}
})(X.DBdefaultEnv);
X.runModel = (function(env) {
	return {
		single: function(tableObject) {
			var row = new X.modelBuilder.tableNode(tableObject);
			row.ready = ko.observable(false);
			row.sendQuery = function() {
				var self = this;
				self.ready(false);
				var sql = X.modelBuilder.makeSQL(self);
				var json = X.modelBuilder.sqlToJSON(sql);
				env.send(json, function(data) { X.runModel.processArray(data, self) });
			}
			return row;
		},
		multi: function(tableObject) {
			var model = {};
			env.makeArray(model, tableObject.name, tableObject);
			return model;
		},
		sendQuery: function(model) {
			for(var i in model) {
				if(model[i].sendQuery) model[i].sendQuery();
			}
		}
	}
})(X.DBdefaultEnv);
X.modelBuilder = (function(env) {
	var makeAlias = function(n) {
			return "abcderfghijklmnopqrstuvwxyz".charAt(n) ||
				makeAlias(n/10)+(n%10);
		}
	var res =
	{
		tableNode: function(tableObject, rel) {
			this.$ = tableObject;
			this.alias = "";
			this.condition = null;
			this.key = null;
			for(var i in tableObject) {
				var fieldObject = tableObject[i];
				if(fieldObject.name) {
					if(fieldObject.target) 
						env.makeRelation(this, i, fieldObject);
					else
						env.makeElement(this, i, fieldObject);
				}
			}
			for(var i in tableObject) {
			//после заведения всех полей, потому что имена в кондишенах 
			//патчатся на ko объекты
				var fieldObject = tableObject[i];
				if(fieldObject.name) {
					if(fieldObject.array) 
						env.makeArray(this, i, fieldObject);
				}
			}
			//TODO: 
			//elm.destroyElement = function(to_destroy) { 
//				this.destroy(to_destroy);
	//			to_destroy.key._destroy = true;
		//		to_destroy.sendToServer();
			//}
			return this;
		},
		traverseRel: function() {
			var key = Array.prototype.join.call(arguments,":") || "";
			//table linked with rel //rel itself
			return this.joins[key] ||
				(this.joins[key] = new X.modelBuilder.tableNode(this.$.target, this));
		},
		//x.rel() == X.modelBuilder.traverseRel(this.rel, arguments)

		patchExternalCondition:function(root, cond) {
			for(var i=0;i<cond.length;++i) {
				cond[i].there = root[cond[i].there];
			}
		},
		makeCondition: function(root, cond, context, rel_params) {
			if(cond.cache && cond.cache[rel_params]) return cond.cache[rel_params]; //cached
			//context.rel root.id, root.field1, field1 = const or field1 = field2
			var real_expr = [];
			for(var i=0;i<cond.length;++i) {
				var expr = { there : eval("root."+cond[i].there), value: cond[i].value };
				if(cond[i].here) expr.here = eval("context."+cond[i].here)
				if(context.alias === "") expr.value = ko.computed(function() {return expr.here()});//дополнительный запрос
				real_expr.push(expr);
			}
			//TODO: find appropriate table in context stack
					// it's changed from call to call so can't be cached - what we should do?
					//BUT!
					// we always has condition in from field1 = const or field1 = field2
					// where field1 is from right table and field2 from context table (which is one level up)
					// at least for now it's always so
					// so! we can just bound field2 to alias later, in sql
			params = rel_params && rel_params.split(':');
			if(params) {
				var p = 0;
				for(var i = 0; i < real_expr.length; ++i)
					if(real_expr[i].value === '?')
						real_expr[i].value = params[p++];
			}
			cond.cache = cond.cache || {};
			return cond.cache[rel_params] = real_expr;
		},
		makeRelsAndAliases: function(table_node, context_node, alias) {
			alias = alias || { current: 0};
			table_node.alias = makeAlias(alias.current++);
			if(table_node.external) this.patchExternalCondition(table_node, table_node.external)
			for(var i in table_node) {
				var rel = table_node[i];
				if(rel && rel.joins) { //it's rel
					for(var j in rel.joins) { //it's rel params
						var target_node = rel.joins[j];
						target_node.condition = 
							X.modelBuilder.makeCondition(target_node, rel.$.condition, table_node, j);
						this.makeRelsAndAliases(target_node, table_node, alias);
					}
				}
			}
		},
		//collectJoins return table_node, if it doesnt have joins or array of joined tables
		// or joins with tablenode as first element
		//table_node or first element of array contains join condition for outer node
		collectJoins: function(table_node) {
			// T1->T2->T3
			// T1 left join (T2 left join T3 on T3.rid = T2.rel) on T2.rid=T1.rel
			// it's returned as [T1, [T2, T3]]
			
			var ret = [];
			for(var i in table_node) {
				var rel = table_node[i];
				if(rel && rel.joins) { //it's rel
					for(var j in rel.joins) { //it's rel params
						ret.push(this.collectJoins(rel.joins[j]));
					}
				}
			}
			
			if(ret == []) {
				//no subjoins -> return table as it is
				return table_node;
			}
			ret.unshift(table_node); // if we have joins, add table to first element in join sequence
			return ret; 
		},
		generateKeyObject: function(table_node) {
			if(table_node.key) return table_node.key;
			var kv = {}
			for(var i in table_node) {
				var elem = table_node[i];
				if(elem && elem.$.pk)
					kv[elem.$.name] = elem;
				if(elem && elem.value && elem.value.$.pk)
					kv[elem.value.$.name] = elem.value;
			}
			return table_node.key = X.DB.new_key(table_node.$, kv);
			//TODO: subscibe to changes
		},
		makeUpdatables: function(table_node) {
			for(var i in table_node) {
				var elem = table_node[i];
				elem = elem && elem.value || elem;
				if(elem && env.boundAsUpdatable(elem)) {
					elem.key = this.generateKeyObject(table_node);
					elem.sendToServer = function() { this.key.sendToServer(this); }
					env.convertToUpdatable(elem);
					//TODO: subscibe to changes
				}
				
				var rel = elem;
				if(rel && rel.joins) { //it's rel
					for(var j in rel.joins)
						this.makeUpdatables(rel.joins[j]);
				}
			}
		},
		collectUsage: function(table_node, used) {
			//here we have condition for this node
			//we should right(!) associate joins under relations
			// T1->T2->T3
			// T1 left join (T2 left join T3 on T3.rid = T2.rel) on T2.rid=T1.rel
			// it's returned as [T1:null [T2(T2.rid=T1.rel) T3(T3.rid = T2.rel)]]
			
			for(var i in table_node) {
				var elem = table_node[i];
				if(elem && env.used(elem) && !elem.defer) used.push({node: table_node, elem: elem});
				var rel = elem;
				if(rel && rel.joins) { //it's rel
					for(var j in rel)
						if(rel[j] && env.used(rel[j]))//value
							used.push({node: table_node, elem: rel[j]});
					for(var j in rel.joins)
						this.collectUsage(rel.joins[j], used);
				}
			}
		},
		setupLinkedUsage:function(table_node) {
			for(var i in table_node) {
				var rel = table_node[i];
				if(rel) {
					if(env.isMulti(rel) && env.used(rel)) {
						rel.external = ko.computed(function() {
							var def = rel.$;
							if(!def.condition) return;
							var rez = [];
							for(var i=0;i<def.condition.length;++i) {
								var cond = def.condition[i];
								var expr = {there: cond.there, value: cond.value, here: cond.here};
								if(rel.defer && cond.here) { 
									expr.value = table_node[cond.here]();
								}
								rez.push(expr);
							}
							return rez;
						});
					}
					else if(rel.joins) {
						for(var j in rel.joins) 
							this.setupLinkedUsage(rel.joins[j]);
					}
				}
			}
		},
		collectSubselects: function(table_node, selects) {
			for(var i in table_node) {
				var rel = table_node[i];
				if(rel) {
					if(rel.auto && env.used(rel)) {
						selects.push(rel.makeQuery(table_node));
					}
					else if(rel.joins) {
						for(var j in rel.joins) 
							this.collectSubselects(rel.joins[j], selects);
					}
				}
			}
		},
		makeSQL: function(table_node, context_node) {
			this.makeUpdatables(table_node);
			this.makeRelsAndAliases(table_node, context_node);
			this.setupLinkedUsage(table_node);
			
			var used = [];
			this.collectUsage(table_node, used);
			var joins = this.collectJoins(table_node);
			var selects = [];
			this.collectSubselects(table_node, selects);
			return {
				joins: joins, //FROM
				used: used, //SELECT
				selects: selects //subselects
			}
		},
		nodeToJSON:function(node) {
			if(!node) return 'error';
			return node.parent ? (node.parent.alias+'.'+node.$.name) : node;
		},
		condToJSON:function(cond) {
			if(!cond) return cond;
			var rez = [];
			for(var i=0;i<cond.length;++i) {
				var expr = {}
				expr[this.nodeToJSON(cond[i].there)] = cond[i].value || this.nodeToJSON(cond[i].here);/*{there: this.nodeToJSON(cond[i].there)};
				if(cond[i].value) expr.value = cond[i].value;
				if(cond[i].here) expr.here = this.nodeToJSON(cond[i].here);
				*/rez.push(expr);
			}
			return rez;
		},
		sqlToJSON: function(sql_object) {
			var self = this;
			var select = [];
			for(var i = 0; i < sql_object.used.length; ++i)
				select.push(sql_object.used[i].node.alias+"."+sql_object.used[i].elem.$.name)
			
			var recf = function(joins) {
				if(!joins.length) // simple table
					return { table: joins.$.name, 
							alias: joins.alias, 
							on: self.condToJSON(joins.condition),
							external: self.condToJSON(joins.external)
						}
				//multijoin
				var res = []
				for(var i = 0; i < joins.length; ++i)
					res.push(recf(joins[i]));
				return res;
			}
			var from = recf(sql_object.joins);
			
			var recs = function(selects) {
				if(X.isArray(selects)) {
					var rez = [];
					for(var i=0;i<selects.length;++i) {
						rez.push(recs(selects[i]));
					}
					return rez;
				} else {
					return self.sqlToJSON(selects);
				}
			}
			var selects = recs(sql_object.selects);
			return { select: select, from: from, selects:selects };
		}
	}
	return res;
})(X.DBdefaultEnv);
function SQLTODATA(sql) {
	var sqlstr = JSON.stringify(sql);
	if(sqlstr=='{"select":["a.f1","a.f2","a.brel0","b.year","b.id","c.f3","d.f1"],"from":[{"table":"T1","alias":"a","on":null},[{"table":"T2","alias":"b","on":[{"b.f2":"?"},{"b.year":"?"},{"b.id":"a.rel1"}]},[{"table":"T3","alias":"c","on":[{"c.id":"b.rel2"}]},[{"table":"T1","alias":"d","on":[{"d.id":"c.rel3"}]}]]]],"selects":[{"select":["a.f0"],"from":[{"table":"T0","alias":"a","on":null,"external":[{"a.rel0":"id"}]}],"selects":[]}]}') {
		return [
			{'a.f1':'Иван','a.f2':'Иванов','a.brel0':[{'f2':1},{'f2':2},{'f2':3}],'b.year':'1981','b.id':'111','c.f3':'Москва','d.f1':'Иван'},
			{'a.f1':'Мария','a.f2':'Петров','a.brel0':[{'f2':4},{'f2':5}],'b.year':'1982','b.id':'222','c.f3':'Воронеж','d.f1':'Мария'},
			{'a.f1':'Грегори','a.f2':'Сидоров','a.brel0':[{'f2':6},{'f2':7},{'f2':8}],'b.year':'1979','b.id':'333','c.f3':'Сочи','d.f1':'Грегори'},
			{'a.f1':'Марк','a.f2':'Третьяк','a.brel0':[{'f2':9}],'b.year':'1983','b.id':'444','c.f3':'Санкт-Петербург','d.f1':'Марк'},
			{'a.f1':'Смит','a.f2':'Джексон','a.brel0':[{'f2':10},{'f2':11},{'f2':12},{'f2':13}],'b.year':'1991','b.id':'555','c.f3':'Москва','d.f1':'Смит'},
			{'a.f1':'Трелони','a.f2':'Ванкрофт','a.brel0':[{'f2':14},{'f2':15}],'b.year':'1954','b.id':'666','c.f3':'Волгоград','d.f1':'Трелони'}
		];
	}
	if(sqlstr=='{"select":["a.f1"],"from":[{"table":"T1","alias":"a","on":null,"external":[{"a.rel1":"777"}]}],"selects":[]}') {
		return [
			{'a.f2':7},{'a.f2':8},{'a.f2':9}
		];
	}
	if(sqlstr=='{"select":["a.f1"],"from":[{"table":"T1","alias":"a","on":null,"external":[{"a.rel1":"666"}]}],"selects":[]}') {
		return [
			{'a.f2':6},{'a.f2':7},{'a.f2':8}
		];
	}
	if(sqlstr=='{"select":["a.f1"],"from":[{"table":"T1","alias":"a","on":null,"external":[{"a.rel1":"555"}]}],"selects":[]}') {
		return [
			{'a.f2':5},{'a.f2':6},{'a.f2':7}
		];
	}
	if(sqlstr=='{"select":["a.f1"],"from":[{"table":"T1","alias":"a","on":null,"external":[{"a.rel1":"444"}]}],"selects":[]}') {
		return [
			{'a.f2':4},{'a.f2':5},{'a.f2':6}
		];
	}
	if(sqlstr=='{"select":["a.f1"],"from":[{"table":"T1","alias":"a","on":null,"external":[{"a.rel1":"333"}]}],"selects":[]}') {
		return [
			{'a.f2':3},{'a.f2':4},{'a.f2':5}
		];
	}
	if(sqlstr=='{"select":["a.f1"],"from":[{"table":"T1","alias":"a","on":null,"external":[{"a.rel1":"222"}]}],"selects":[]}') {
		return [
			{'a.f2':2},{'a.f2':3},{'a.f2':4}
		];
	}
	if(sqlstr=='{"select":["a.f1"],"from":[{"table":"T1","alias":"a","on":null,"external":[{"a.rel1":"111"}]}],"selects":[]}') {
		return [
			{'a.f2':1},{'a.f2':2},{'a.f2':3}
		];
	}
	
}
function Init() {
	var M = X.runModel.multi(metaModel['T1']);
	ko.applyBindings(M);
	X.runModel.sendQuery(M);
}
</script>
</body>
</html>
dataflow

1) начинаем в "выходной" страницы
она может быть
	- шаблоном
	- простым форматом
			html
			xml by <table field=value> | <table><field value=??/> | <table><field>value</field>
				при этом мы задаем:
					вывод имени в тэге или отдельным атрибутом
					вывод значения в одно из 3-х форматов выше
						(attribute, value, content)
	- xls.xml, xlsx, doc.xml, docx, rtf ...
	- csv
	- выбором формата (просто диспетчер)
	- GUI
	- import - кладет в базу и возвращает заменненные id

2) страница получает данные из команды (+аргументы)
	источники могут быть
	SELECT .... + args
	URL ENDPOINT .... + args
	<query> + args
	<xsl:...> + command + args
	<another xml>
при этом если задан URL мы идем: 
	а) в конфигурацию, находим реальный адрес
	б) проверяем права
	в) выполняем запрос и возвращаемся в цикле к обработке результатов
если задан xsl мы производим трансляцию им следующего xml и возврящаемся с обработке результатов
если задан query - транслируем его в SQL
если задан xml - разбираем его в объекты!

3) надо ли соединять обработчики в цепочку?
вариант
	template <xsl:>out</xsl:> <xsl:>in</xsl:> <external-query>
	это работает по умолчанию

может быть полезно
	template <xsl:out> call:template sql

в этом цепочке мы
1) подключаем обработчик (он ничего(!) не выполняет)
2) вызываем его стартовую ф-ю с уже готовыми новыми аргументам
надо ли регистрировать template?
	- его всегда можно вызвать по урл и так
	- он сам по себе ничего не делает
	- он сам может проверять права
		(но это не нужно, т.к. этим может заняться и команда)
все template отсчитываем от определенной директории


шаблоны
1) репозиционирование
2) заворт тэгов в неэекранированные
3) вывод по месту

репозиционирование переносит следующую команду выше
[[-tag:ops]]
[[-tag@:ops]]
[[-tag@attribute:ops]]
[[-tag:ops{-:-}ops]]
мы делим по позиции -:-, то, что "до" идет до тэга, после - после тэга
вставка атрибута идет в конец
	варианты
		[[-tag@attribute:ops]] - вставляет atribute="value"
		[[-tag@:ops]] - вставляет ops внутрь тэга (через пробел)
особые варианты tag - 
	1) пусто: тут мы репозиционируем тэг на начало строки
		проблема тут - где конечный?
	2) {} - смещаемся до скобки

во всех ops обрабатываем
	.gt. .lt. .ge. .le. .eq. .ne. .or. .and.

специальные команды
	[[=start_cut]]
	[[=cut_to:variable_name]]
	[[=skip:condition]] ===> [[if(condition) continue;]]
	[[=coonector]] ===> дописываем хвост, если будет вывод следующего цикла
		====>	
		<tr><td>
		[[-tr:foreach($rows as $row){ start_loop(); -:- end_conncetor(); }]]
		...
			[[=connector]]<br>

		</td></tr>

	коннекторы:
		перед началом $connector = null;
		на каждом проходе if($connector) echo $connector;
		по команде коннектора ob_start(), $connector = '';
		в конце цикла, if($connector === '') $connector = ob_end_clean();
		

вывод поля
	[[field:commands]]
	[[$var:commands]]
команды
	:value - первая команда - значение по умолчанию, если нет ::
	далее операции
	:SUBSTR(pos,len)
	:LPAD(len, symbol)
	:RPAD(len, symbol)
	:TRIM
	:RE(reg_exp) - выделяет полное совпадение, или, если есть - 1-ю скобку
	:RU_DATE - заменяет начало даты
	:RU_NUMBER(left_words, factional_words) - если нет слов - числом
команды идут цепочкой
	команды завершаются
	1) вводом, если нет завершителя
	2) :$var - записью в переменную

еще бы нужны группировки!
